import funkin.ui.freeplay.FreeplayState;
import funkin.modding.module.Module;
import funkin.audio.FunkinSound;
import funkin.util.ReflectUtil;
import funkin.Paths;
import flixel.FlxG;
import StringTools;

/**
 * A Module that replaces music with different audio.
 * This can be helpful if you want to replace any menu songs.
 * Made for Funkin' Remnants.
 *
 * You are free to use this for your own mod, just please give me credit!
 * @author TechnikTil
 */
class RemnantsMusicReplacer extends Module
{
  /**
   * Initialize all music that should be replaced.
   * Put all music that you want to replace here.
   */
  public function initialize():Void
  {
    // This tells the module that `freeplayRandom` should be replaced with `freeplayRandom-remnants`.
    // The third argument is completely optional.
    addReplacement('freeplayRandom', 'freeplayRandom-remnants', () -> {
      // If the current freeplay character is Funkin' their Remnants, replace the music.
      return StringTools.contains(FreeplayState.rememberedCharacterId, 'remnants');
    });

    addReplacement('freakyMenu', 'freakyMenu-remnants', RemnantsContentUtil.remnantsContentEnabled);
    addReplacement('girlfriendsRingtone', 'tutorialTitle', RemnantsContentUtil.remnantsContentEnabled);
  }

  /**
   * Adds a music replacement to the registry.
   * @param original The song to replace.
   * @param replace The song that it should be replaced with.
   * @param condition An optional condition that needs to be `true` for the music to be replaced.
   */
  public function addReplacement(original:String, replace:String, ?condition:Null<Void->Bool>):Void
  {
    var sound:Sound = null;
    var path:String = Paths.music(replace + "/" + replace);
    if (FlxG.assets.exists(path, "sound"))
    {
      sound = FlxG.assets.getSoundUnsafe(path);
    }

    musicReplaceRegistry.push([original, condition, sound]);
  }

  /**
   * Array index goes: Original, Condition, Sound
   * Would use an `ObjectMap`, but it would always return `null`?
   */
  var musicReplaceRegistry:Array<Array<Dynamic>>;

  /**
   * Internal, used for only checking labels once.
   */
  var lastRememberedLabel:String = null;

  public function new()
  {
    super('RemnantsMusicReplacer', 5000);

    musicReplaceRegistry = [];
    initialize();
  }

  /**
   * Checks and replaces the audio if registered.
   * @param sound Sound to check.
   */
  public function checkAndReplaceSound(sound:FunkinSound):Void
  {
    // Check the registry and see if the music playing should be replaced.
    var musicReplaceEntry:Array<Dynamic> = null;

    for (entry in musicReplaceRegistry)
    {
      var musicID:String = entry[0];

      var musicPath:String = Paths.music(musicID + "/" + musicID);
      if (sound._label == musicPath && sound._sound != entry[2])
      {
        musicReplaceEntry = entry;
        break;
      }
    }

    // Don't do anything if theres nothing to replace.
    if (musicReplaceEntry == null) return;

    // Run the condition, if it fails, don't do anything.
    var condition:Void->Bool = musicReplaceEntry[1];
    if (condition != null && !condition()) return;

    // Hackily replace the internal sound with our replaced sound.
    trace('Replacing ' + musicReplaceEntry[0] + '...');
    replaceSound(sound, musicReplaceEntry[2]);
    trace('Replaced successfully!');
  }

  /**
   * Hackily replace the sound with a different audio.
   * This will also adjust any length variables to the new sound.
   * If you get any errors from this line, please contact me and I'll fix it ASAP.
   *
   * @param sound The `FlxSound` instance that should have new audio.
   * @param newSound The new audio.
   */
  public function replaceSound(sound:FlxSound, newSound:Sound):Void
  {
    var wasntStopped:Bool = sound._channnel == null;
    var time:Float = wasntStopped ? sound._channel.position : 0;
    var oldLength:Float = sound._length;

    sound.cleanup(false, false);

    // Debating on this one.
    // sound._sound.removeEventListener("id3", sound.gotID3);
    sound._sound = null;

    sound._sound = newSound;
    sound._length = newSound.length;

    if (oldLength != sound.endTime) sound.endTime = newSound.length;

    if (wasntStopped && !sound._paused) sound.startSound(time);
  }

  public function onUpdate(event:UpdateScriptEvent):Void
  {
    // Maybe search sounds outside of `FlxG.sound.music`?

    // Don't do anything if the music isn't proper music.
    if (FlxG.sound.music == null || !Std.isOfType(FlxG.sound.music, FunkinSound)) return;

    // Don't check the same sound multiple times.
    if (FlxG.sound.music._label == lastRememberedLabel) return;
    lastRememberedLabel = FlxG.sound.music._label;

    checkAndReplaceSound(FlxG.sound.music);
  }

  public function onStateChangeEnd(event:StateChangeScriptEvent):Void
  {
    // Reset the last remembered label between state switches.
    // This is so the condition has a chance to be called again.
    lastRememberedLabel = null;
  }
}

