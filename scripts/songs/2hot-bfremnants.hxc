import flixel.util.FlxTimer;
import funkin.util.HapticUtil;
import flixel.tweens.FlxTween;
import funkin.modding.module.ModuleHandler;
import funkin.modding.base.ScriptedFunkinSprite;
import funkin.graphics.FunkinSprite;
import funkin.play.GameOverSubState;
import funkin.play.stage.StageProp;
import funkin.play.song.Song;
import funkin.play.PlayState;
import funkin.FunkinMemory;
import funkin.save.Save;
import funkin.audio.FunkinSound;

class TwoHOTRemnantsBFMixSong extends Song
{
  function new()
  {
    super('2hot',
      {
        variation: 'bfremnants'
      });

    hasPlayedCutscene = false;
  }

  function onCreate(event:ScriptEvent)
  {
    super.onCreate(event);

    // Precache the spraycan atlas.
    FunkinMemory.cacheTexture(Paths.image("remnants/mechanics/spraycanAtlas/spritemap1"));

    PlayState.instance.currentStage.getGirlfriend().x = 1050;
  }

  public override function isSongNew(currentDifficulty:String, currentVariation:String):Bool
  {
    if (currentVariation == 'bfremnants') return !Save.instance.hasBeatenSong(this.id, null, this.variation);
    return false;
  }

  public override function listAltInstrumentalIds(difficultyId:String, variationId:String):Array<String>
  {
    var results:Array<String> = super.listAltInstrumentalIds(difficultyId, variationId);
    var hasBeatenRemnantsMix = Save.instance.hasBeatenSong(this.id, null, this.variation);
    if (difficultyId == 'easy' || difficultyId == 'normal' || difficultyId == 'hard')
    {
      var hasBeatenPicoMix = Save.instance.hasBeatenSong(this.id, null, 'pico');
      if (!hasBeatenPicoMix) results.remove('pico');
    }
    if (hasBeatenRemnantsMix) return results;
  }

  function onCountdownStart(event:ScriptEvent):Void
  {
    super.onCountdownStart(event);

    if (!ModuleHandler.getModule('RemnantsBumpers').scriptCall('getPlayedBumper')
      && ModuleHandler.getModule('RemnantsBumpers').scriptCall('setupBumper'))
    {
      event.cancel();
      ModuleHandler.getModule('RemnantsBumpers').scriptCall('setPlayedBumper', true);
    }
  }

  function onSongRetry(event:ScriptEvent)
  {
    super.onSongRetry(event);

    PlayState.instance.currentStage.getGirlfriend().x = 1050;

    removeCans();
    micCocked = false;
  }

  function removeCans()
  {
    for (can in spawnedCans)
    {
      can.kill();
    }
    spawnedCans = [];
  }

  function onStateChangeEnd(event:StateChangeScriptEvent)
  {
    super.onStateChangeEnd(event);

    if ((Std.isOfType(event.targetState, PlayState)))
    {
      return;
    }
    hardClear();
  }

  function hardClear()
  {
    removeCans();
    micCocked = false;
  }

  var micCocked:Bool = false;
  var spawnedCans:Array<ScriptedFunkinSprite> = [];

  function onNoteHit(event:HitNoteScriptEvent)
  {
    super.onNoteHit(event);
    if (PlayState.instance.currentStage == null) return;

    switch (event.note.kind)
    {
      case "weekend-1-lightcan":
        // Do nothing, but place this such that the animation plays at the right time.
      case "weekend-1-kickcan":
        // This creates the can and starts the animation.
        // We define the behavior of the can in a separate scripted class,
        // which allows the can to track and manage its own properties.
        var newCan:ScriptedFunkinSprite = ScriptedFunkinSprite.init('SpraycanAtlasSpriteRemnants', 0, 0);
        var spraycanPile = PlayState.instance.currentStage.getNamedProp('spraycanPile');

        newCan.x = spraycanPile.x - 100;
        newCan.y = spraycanPile.y - 550;
        newCan.zIndex = spraycanPile.zIndex - 1;

        newCan.scriptCall('playCanStart');

        PlayState.instance.currentStage.add(newCan);
        PlayState.instance.currentStage.refresh(); // Apply z-index.
        spawnedCans.push(newCan);
      case "weekend-1-kneecan":
        // Do nothing, but place this such that the animation plays at the right time.
      case "bf-prep":
        micCocked = true;
        new FlxTimer().start(1.0, function() {
          micCocked = false;
        });
      case "bf-attack":
        if (micCocked)
        {
          trace('Firing gun!');
          shootNextCan();
        }
        else
        {
          trace('Cannot fire gun!');
          // The player cannot hit this note.
          event.cancelEvent();
        }
    }
  }

  public var STATE_ARCING:Int = 2; // In the air.
  public var STATE_SHOT:Int = 3; // Hit by the player.
  public var STATE_IMPACTED:Int = 4; // Impacted the player.

  function getNextCanWithState(desiredState:Int)
  {
    for (index in 0...spawnedCans.length)
    {
      var can = spawnedCans[index];
      var canState = can.scriptGet('currentState');

      if (canState == desiredState)
      {
        // Return the can we found.
        return can;
      }
    }
    return null;
  }

  function darkenStageProps()
  {
    // Darken the background, then fade it back.
    for (stageProp in PlayState.instance.currentStage.members)
    {
      // Determine if the stage prop is something that should be excluded from darkening.
      if (Std.isOfType(stageProp, StageProp))
      {
        if (stageProp.name == "bf" || stageProp.name == "dad" || stageProp.name == "gf") // This refers to the player.
        {
          // Exclude.
          continue;
        }

        // Newspaper.
        if (stageProp.name == "paper")
        {
          // Exclude.
          continue;
        }
      }

      // Select cans.
      if (spawnedCans.contains(stageProp))
      {
        // Exclude.
        continue;
      }

      // Hacky way of selecting the mist objects.
      // They are not public so this is the only way i think.
      if (stageProp.zIndex == 1000 || stageProp.zIndex == 1001 || stageProp.zIndex == 99 || stageProp.zIndex == 88 || stageProp.zIndex == 39)
      {
        // Exclude.
        continue;
      }

      // Hacky way of selecting PicoPlayable.picoFade.
      if (stageProp.zIndex == (PlayState.instance.currentStage.getBoyfriend().zIndex - 3))
      {
        // Exclude.
        continue;
      }

      // If not excluded, darken.
      stageProp.color = 0xFF111111;
      new FlxTimer().start(1 / 24, (tmr) -> {
        stageProp.color = 0xFF222222;
        FlxTween.color(stageProp, 1.4, 0xFF222222, 0xFFFFFFFF);
      });
    }
  }

  function blackenStageProps()
  {
    // Blacken the background (also Darnell and Nene) entirely, then restore it once the gameOverSubState is up.
    for (stageProp in PlayState.instance.currentStage.members)
    {
      // Determine if the stage prop is something that should be excluded from blackening.
      if (Std.isOfType(stageProp, StageProp))
      {
        if (stageProp.name == "bf") // This refers to the player.
        {
          // Exclude.
          continue;
        }

        // Newspaper.
        if (stageProp.name == "paper")
        {
          // Exclude.
          continue;
        }
      }

      // Hacky way of selecting the mist objects.
      // They are not public so this is the only way i think.
      if (stageProp.zIndex == 1000 || stageProp.zIndex == 1001 || stageProp.zIndex == 99 || stageProp.zIndex == 88 || stageProp.zIndex == 39)
      {
        // Exclude.
        continue;
      }

      // Select cans.
      if (spawnedCans.contains(stageProp))
      {
        // Exclude.
        continue;
      }

      // If not excluded, blacken.
      stageProp.color = 0xFF000000;
      new FlxTimer().start(1.0, (tmr) -> {
        stageProp.color = 0xFFFFFFFF;
      });
    }
  }

  function shootNextCan()
  {
    var can = getNextCanWithState(STATE_ARCING);

    if (can != null)
    {
      can.scriptSet('currentState', STATE_SHOT);
      can.scriptCall('playCanShot');
      FunkinSound.playOnce(Paths.sound('bfAttack', "week1"), 1);

      new FlxTimer().start(1 / 24, function(tmr) {
        darkenStageProps();
      });
    }
  }

  function missNextCan()
  {
    var can = getNextCanWithState(STATE_ARCING);

    if (can != null)
    {
      can.scriptSet('currentState', STATE_IMPACTED);
    }
  }

  function spawnImpactParticle()
  {
    var impactParticle = FunkinSprite.createSparrow(0, 0, 'remnants/mechanics/CanImpactParticle');
    impactParticle.animation.addByPrefix('idle', 'CanImpactParticle0', 24, false);
    impactParticle.animation.play('idle');
    impactParticle.x = PlayState.instance.currentStage.getBoyfriend().x + 400;
    impactParticle.y = PlayState.instance.currentStage.getBoyfriend().y - 200;
    PlayState.instance.currentStage.add(impactParticle);

    impactParticle.animation.finishCallback = function() {
      impactParticle.kill();
    };
  }

  function onNoteMiss(event:NoteScriptEvent)
  {
    super.onNoteMiss(event);

    trace('Missed note on 2hot stage...' + event.note.noteData);

    switch (event.note.kind)
    {
      case "bf-prep":
        event.healthChange = 0.0; // We cause health loss later.
      case "bf-attack":
        micCocked = false;
        event.healthChange = 0.0; // We cause health loss elsewhere.
        missNextCan();
        takeCanDamage();
    }
  }

  /**
   * Health lost when hit by can.
   */
  var HEALTH_LOSS = 0.25 * 2;

  var canDamageVibrationPreset:VibrationPreset =
    {
      period: 0.1,
      duration: 0.1,
      amplitude: 1,
      sharpness: 1
    };

  function takeCanDamage():Void
  {
    trace('Taking damage from can exploding!');

    PlayState.instance.health -= HEALTH_LOSS;
    // TODO: This is jank as hell! Add some better way to prevent onNoteMiss's normal health loss.
    // PlayState.instance.health += 0.0775;

    if (PlayState.instance.health <= 0)
    {
      trace('Died to the can! Use special death animation.');

      // Reset to standard death animation.
      GameOverSubState.musicSuffix = '-bf-explode-remnants';
      GameOverSubState.blueBallSuffix = '-bf-explode-remnants';

      if (!PlayState.instance.isPracticeMode) blackenStageProps();
    }
    else if (HapticUtil.hapticsAvailable)
    {
      // Can hits bf.
      HapticUtil.vibrateByPreset(canDamageVibrationPreset);

      new FlxTimer().start(0.45, function(tmr) {
        // Can explodes.
        HapticUtil.vibrateByPreset(canDamageVibrationPreset);
      });
    }
  }
}
