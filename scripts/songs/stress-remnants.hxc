import funkin.play.song.Song;
import funkin.play.PlayState;
import funkin.save.Save;
import funkin.play.GameOverSubState;
import funkin.modding.base.ScriptedFlxSpriteGroup;
import flixel.FlxG;
import flixel.text.FlxText;
import flixel.text.FlxTextBorderStyle;
import funkin.play.character.BaseCharacter;
import funkin.play.character.CharacterDataParser;
import funkin.modding.events.ScriptEventDispatcher;
import funkin.modding.events.SongTimeScriptEvent;
import funkin.play.character.CharacterType;
import funkin.data.song.SongRegistry;
import funkin.modding.module.ModuleHandler;
import funkin.modding.base.ScriptedFunkinSprite;
import funkin.ui.FullScreenScaleMode;
import funkin.Conductor;
import funkin.graphics.FunkinSprite;
import flixel.tweens.FlxEase;
import flixel.tweens.FlxTween;
import flixel.util.FlxTimer;
import flixel.util.FlxTimerManager;
import funkin.graphics.FunkinSprite;
import funkin.audio.FunkinSound;
import funkin.util.TouchUtil;
import funkin.Preferences;

class StressRemnantsMixSong extends Song
{
  var tankmanGroup:TankmanSpriteGroupRemnants = null;
  var bgSprite:FunkinSprite = null;

  var hasPlayedCutscene:Bool = false;
  var canSkipCutscene:Bool = false;
  var cutsceneSkipped:Bool = false;
  var isMobilePauseButtonPressed:Bool = false;
  var skipText:FlxText;

  var cutsceneConductor:Conductor;
  var cutsceneTimerManager:FlxTimerManager;
  var cutsceneMusic:FunkinSound;

  public function new()
  {
    super('stress',
      {
        variation: 'remnants'
      });

    hasPlayedCutscene = false;
  }

  /**
   * Replay the cutscene after leaving the song.
   */
  function onCreate(event:ScriptEvent):Void
  {
    super.onCreate(event);

    hasPlayedCutscene = false;
    canSkipCutscene = false;
    cutsceneSkipped = false;

    bgSprite = new FunkinSprite(0, 0);
    bgSprite.makeSolidColor(FlxG.width * 2, FlxG.height * 2, 0xFF000000);
    bgSprite.screenCenter();
    bgSprite.cameras = [PlayState.instance.camCutscene];
    bgSprite.zIndex = -10000;
    bgSprite.alpha = 0;
    PlayState.instance.add(bgSprite);
    PlayState.instance.refresh();
  }

  public override function isSongNew(currentDifficulty:String, currentVariation:String):Bool
  {
    if (currentVariation == 'remnants') return !Save.instance.hasBeatenSong(this.id, null, this.variation);
    return false;
  }

  public override function onCountdownStart(event:CountdownScriptEvent):Void
  {
    super.onCountdownStart(event);

    if (!ModuleHandler.getModule('RemnantsBumpers').scriptCall('getPlayedBumper')
      && ModuleHandler.getModule('RemnantsBumpers').scriptCall('setupBumper'))
    {
      bgSprite.alpha = 1;

      ModuleHandler.getModule('RemnantsBumpers').scriptCall('setPlayedBumper', true);
      event.cancel();
    }
    else if (!hasPlayedCutscene)
    {
      trace('Pausing countdown to play in-game cutscene (`stress-remnants`)');

      hasPlayedCutscene = true;

      event.cancel(); // CANCEL THE COUNTDOWN!

      runCutscene();

      bgSprite.alpha = 1;
      FlxTween.tween(bgSprite, {alpha: 0}, 1);
    }

    if (tankmanGroup != null && !tankmanGroup.scriptCall('isValid'))
    {
      // Destroy the tankman group if it's not valid.
      tankmanGroup.destroy();
      PlayState.instance.currentStage.remove(tankmanGroup);
      tankmanGroup = null;
    }

    if (tankmanGroup == null)
    {
      // Initialize the tankman group if it's not available.
      trace('Initializing tankman group...');
      tankmanGroup = ScriptedFlxSpriteGroup.init('TankmanSpriteGroupRemnants', false);
    }

    if (tankmanGroup != null)
    {
      // resets the tankmen!
      tankmanGroup.scriptCall('reset');

      tankmanGroup.zIndex = 30;
      PlayState.instance.currentStage.add(tankmanGroup);
      PlayState.instance.currentStage.refresh();
    }
    else
    {
      trace('Failed to initialize tankman group!');
    }
  }

  var cutsceneSounds:Array<FunkinSound> = [];
  var cutsceneTimeDummy:FunkinSound = null;

  var cameraFollowPoint:FlxPoint = null;

  var tankmanCutscene:FunkinSprite = null;
  var picoCutscene:FunkinSprite = null;
  var fakeBoyfriend:BaseCharacter = null;
  var fakeGirlfriend:BaseCharacter = null;
  var gfFaceplant:FunkinSprite = null;

  function runCutscene():Void
  {
    PlayState.instance.isInCutscene = true;
    PlayState.instance.mayPauseGame = false;
    PlayState.instance.camHUD.visible = false;
    PlayState.instance.camCutscene.visible = true;
    PlayState.instance.currentCameraZoom = 1.035;

    cameraFollowPoint = PlayState.instance.cameraFollowPoint;
    cameraFollowPoint.setPosition(700, 500);
    FlxG.camera.snapToTarget();

    skipText = new FlxText(936 * FullScreenScaleMode.wideScale.x, 618 * FullScreenScaleMode.wideScale.y, 0,
      'Skip [ ' + PlayState.instance.controls.getDialogueNameFromToken("CUTSCENE_ADVANCE", true) + ' ]', 20);
    if (FlxG.onMobile)
    {
      skipText.text = 'Skip [Pause Button]';
      skipText.x -= 136;
    }
    skipText.setFormat(Paths.font('vcr.ttf'), 40, 0xFFFFFFFF, "right", FlxTextBorderStyle.OUTLINE, 0xFF000000);
    skipText.scrollFactor.set();
    skipText.borderSize = 2;
    skipText.alpha = 0;
    PlayState.instance.add(skipText);

    skipText.cameras = [PlayState.instance.camCutscene];

    cutsceneTimerManager = new FlxTimerManager();
    cutsceneSounds = [];

    cutsceneMusic = FunkinSound.load(Paths.music("klaskiiRomper/klaskiiRomper", "week7"), 1, true);
    cutsceneSounds.push(cutsceneMusic);

    if (PlayState.instance.subtitles != null)
    {
      cutsceneTimeDummy = new FunkinSound();
      cutsceneSounds.push(cutsceneTimeDummy);

      // These are off-sync, so disabled for now.
      // @SPG64 can you fix these pretty please ????
      /*var subtitlesFile:String = 'songs/' + PlayState.instance.currentSong.id + '/subtitles/cutscene-remnants';

        if (Preferences.naughtyness)
        {
          subtitlesFile += '-censored';
        }

        PlayState.instance.subtitles.assignSubtitles(subtitlesFile, cutsceneTimeDummy); */
    }

    var tankTalk:FunkinSound = FunkinSound.load(Paths.sound('stressCutscene1'), 1, false);
    cutsceneSounds.push(tankTalk);

    var tankTalk2:FunkinSound = FunkinSound.load(Paths.sound('stressCutscene2'), 1, false);
    cutsceneSounds.push(tankTalk2);

    if (!Preferences.naughtyness)
    {
      var censorBeep:FunkinSound = FunkinSound.load(Paths.sound("censorBeep"), 1, false);
      cutsceneSounds.push(censorBeep);
    }

    gunPoint = FunkinSound.load(Paths.sound("gunPoint"), 1, false);
    cutsceneSounds.push(gunPoint);

    demonEye = FunkinSound.load(Paths.sound("demonEye"), 1, false);
    cutsceneSounds.push(demonEye);

    gunHit = FunkinSound.load(Paths.sound("picoArrives"), 1, false);
    cutsceneSounds.push(gunHit);

    steveDies = FunkinSound.load(Paths.sound("steveDies"), 1, false);
    cutsceneSounds.push(steveDies);

    gfFail = FlxG.random.bool(15);
    if (gfFail) trace("Girlfriend is face-planting!");

    var dadPosition:FlxPoint = PlayState.instance.currentStage.getDadPosition();
    var gfPosition:FlxPoint = PlayState.instance.currentStage.getGirlfriendPosition();

    PlayState.instance.currentStage.getDad().visible = false;
    PlayState.instance.currentStage.getGirlfriend().visible = false;
    PlayState.instance.currentStage.getBoyfriend().visible = false;

    fakeGirlfriend = CharacterDataParser.fetchCharacter('gf-tankmen-remnants');
    setupCharacter(fakeGirlfriend, CharacterType.GF);
    PlayState.instance.currentStage.add(fakeGirlfriend);

    fakeBoyfriend = CharacterDataParser.fetchCharacter('bf-remnants');
    setupCharacter(fakeBoyfriend, CharacterType.BF);
    PlayState.instance.currentStage.add(fakeBoyfriend);

    tankmanCutscene = ScriptedFunkinSprite.init('TankCutsceneRemnants', dadPosition.x - 316, dadPosition.y - 725);
    tankmanCutscene.zIndex = PlayState.instance.currentStage.getDad().zIndex;
    PlayState.instance.currentStage.add(tankmanCutscene);

    picoCutscene = ScriptedFunkinSprite.init('StressSpeakerCutsceneRemnants', gfPosition.x - 1194.5, gfPosition.y - 1130);
    picoCutscene.zIndex = PlayState.instance.currentStage.getGirlfriend().zIndex;
    picoCutscene.visible = false;
    PlayState.instance.currentStage.add(picoCutscene);

    if (gfFail)
    {
      gfFaceplant = FunkinSprite.createSparrow(gfPosition.x + 123.5, gfPosition.y - 139, "remnants/cutscene/gfFail");
      gfFaceplant.animation.addByPrefix('faceplant', "", 24, false);
      gfFaceplant.zIndex = PlayState.instance.currentStage.getBoyfriend().zIndex + 1;
      gfFaceplant.visible = false;
      gfFaceplant.animation.onFinish.add(() -> {
        // loop the twitching, its too funny to only play once!
        gfFaceplant.animation.play('faceplant', true, false, 10);
      });
      PlayState.instance.currentStage.add(gfFaceplant);
    }

    PlayState.instance.currentStage.refresh();

    cutsceneConductor = new Conductor();

    var songMusicData:Null<SongMusicData> = SongRegistry.instance.parseMusicData('stressCutscene');
    if (songMusicData != null) cutsceneConductor.mapTimeChanges(songMusicData.timeChanges);
    cutsceneConductor.onStepHit.add(onCutsceneStepHit);
    cutsceneConductor.onBeatHit.add(onCutsceneBeatHit);

    new FlxTimer(cutsceneTimerManager).start(0, function(_) {
      tankmanCutscene.playAnimation('godEffingDamnIt', true);

      tankTalk.play();

      cutsceneMusic.play();
      cutsceneMusic.fadeIn(5.0, 0.0, 0.1);

      cameraFollowPoint.x = 500;
      PlayState.instance.resetCamera(false, false, false);
    });

    var picoGfFell:Void->Void = null;

    new FlxTimer(cutsceneTimerManager).start(15.9, function(_) {
      cameraFollowPoint.setPosition(670, 330);
      PlayState.instance.resetCamera(false, false, false);

      fakeGirlfriend.destroy();
      fakeGirlfriend = null;

      gunPoint.play();

      picoCutscene.visible = true;
      picoCutscene.playAnimation("gfTurn", true);

      new FlxTimer(cutsceneTimerManager).start(1.24, function(_) {
        demonEye.play(true);
      });

      var picoAnimPhase:Int = 0;
      picoCutscene.anim.onFinish.add((_) -> {
        switch (picoAnimPhase)
        {
          case 0:
            picoCutscene.playAnimation('picoSaves', true);
            picoCutscene.onGirlfriendFell.add(picoGfFell);
            PlayState.instance.currentCameraZoom = 0.8;
            gunHit.play();

            new FlxTimer(cutsceneTimerManager).start(1.05, function(_) {
              steveDies.play();
            });
          case 1:
            picoCutscene.playAnimation('idle', true);
          default:
            picoCutscene.visible = false;
            PlayState.instance.currentStage.getGirlfriend().visible = true;
        }

        picoAnimPhase++;
      });

      PlayState.instance.tweenCameraZoom(1.3455, 2.1, true, FlxEase.quadInOut);
    });

    // Wait 2 frames before playing any animation, so Girlfriend falling makes sense.
    picoGfFell = function() {
      if (gfFail)
      {
        cameraFollowPoint.setPosition(670, 530);
        PlayState.instance.resetCamera(false, false, false);

        gfFaceplant.visible = true;
        gfFaceplant.animation.play("faceplant", true);

        // Replace Boyfriend and Girlfriend with just Boyfriend.
        var oldBF:BaseCharacter = PlayState.instance.currentStage.getBoyfriend(true);
        oldBF.destroy();
        PlayState.instance.currentStage.characters.set('bf', fakeBoyfriend);
        fakeBoyfriend.characterType = CharacterType.BF;
        fakeBoyfriend = null;

        PlayState.instance.currentStage.getBoyfriend().playAnimation('dodge', true, true);
        PlayState.instance.currentStage.getBoyfriend().animation.onFinish.addOnce(() -> {
          // force the idle animation.
          PlayState.instance.currentStage.getBoyfriend().canPlayOtherAnims = true;
          PlayState.instance.currentStage.getBoyfriend().dance(true);
        });
      }
      else
      {
        fakeBoyfriend.destroy();
        fakeBoyfriend = null;

        PlayState.instance.currentStage.getBoyfriend().visible = true;
        PlayState.instance.currentStage.getBoyfriend().playAnimation("bfCatch", true, true);
        PlayState.instance.currentStage.getBoyfriend().animation.onFinish.addOnce(() -> {
          // force the idle animation.
          PlayState.instance.currentStage.getBoyfriend().canPlayOtherAnims = true;
          PlayState.instance.currentStage.getBoyfriend().dance(true);
        });
      }
    };

    new FlxTimer(cutsceneTimerManager).start(20.492, function(_) {
      tankmanCutscene.playAnimation("lookWhoItIs", true);
      tankTalk2.play();
    });

    new FlxTimer(cutsceneTimerManager).start(21.192, function(_) {
      cameraFollowPoint.setPosition(590, 510);
      PlayState.instance.resetCamera(false, false, false);
    });

    new FlxTimer(cutsceneTimerManager).start(32.3, function(_) {
      cameraFollowPoint.setPosition(990, 660);
      PlayState.instance.resetCamera(false, false);

      PlayState.instance.currentCameraZoom = 1.26;
      PlayState.instance.tweenCameraZoom(1.36, 0.5, true, FlxEase.elasticOut);

      PlayState.instance.currentStage.getBoyfriend().playSingAnimation(2, true);

      // You can see the audience member getting cut off usually.
      // Lets make sure we don't see that.
      var tankman:StageProp = PlayState.instance.currentStage.getNamedProp('tankmanAudience3');
      if (tankman != null) tankman.visible = false;

      PlayState.instance.currentStage.getBoyfriend().animation.onFinish.addOnce(() -> {
        PlayState.instance.currentStage.getBoyfriend().dance(true);

        cameraFollowPoint.setPosition(590, 510);
        PlayState.instance.resetCamera(false, false);

        PlayState.instance.currentCameraZoom = 0.97;

        // Let's show it again.
        if (tankman != null) tankman.visible = true;
      });
    });

    new FlxTimer(cutsceneTimerManager).start(34.4, function(_) {
      cutsceneSkipped = true;
      canSkipCutscene = false;

      FlxTween.tween(skipText, {alpha: 0}, 0.5, {ease: FlxEase.quadOut});

      cutsceneMusic.fadeOut(0.5, 0, function(_) {
        cutsceneMusic.stop();
        cutsceneMusic.destroy();
        cutsceneConductor = null;
        cutsceneMusic = null;
      });
    });

    new FlxTimer(cutsceneTimerManager).start(36, function(_) {
      PlayState.instance.cameraFollowPoint.setPosition(PlayState.instance.currentStage.getDad().cameraFocusPoint.x,
        PlayState.instance.currentStage.getDad().cameraFocusPoint.y);
      PlayState.instance.tweenCameraZoom(1, 0.5, false, FlxEase.quadInOut);

      endCutscene();
    });
  }

  function skipCutscene():Void
  {
    cutsceneSkipped = true;
    canSkipCutscene = false;

    PlayState.instance.camCutscene.fade(0xFF000000, 0.5, false, null, true);

    while (cutsceneSounds.length > 0)
    {
      var sound:FunkinSound = cutsceneSounds.pop();
      sound.fadeOut(0.5, 0, function(_) {
        sound.stop();
        sound.destroy();
        sound = null;
      });
    }

    // The camera used for subtitles is ABOVE `camCutscene`.
    // So let's destroy it before anyone sees the problem!
    if (PlayState.instance.subtitles != null)
    {
      PlayState.instance.subtitles.assignedSound = null;
      PlayState.instance.subtitles.subtitlesData = null;
      PlayState.instance.subtitles.setText([], true);
      cutsceneTimeDummy = null;
    }

    new FlxTimer(cutsceneTimerManager).start(0.5, _ -> {
      PlayState.instance.justUnpaused = true;
      PlayState.instance.camCutscene.fade(0xFF000000, 0.5, true, null, true);

      cutsceneConductor = null;

      PlayState.instance.cameraFollowPoint.setPosition(PlayState.instance.currentStage.getDad().cameraFocusPoint.x,
        PlayState.instance.currentStage.getDad().cameraFocusPoint.y);
      PlayState.instance.resetCamera(true, true, true);

      skipText.visible = false;

      endCutscene();
    });
  }

  function endCutscene():Void
  {
    cutsceneTimerManager.clear();
    cutsceneTimerManager.destroy();
    cutsceneTimerManager = null;

    skipText.destroy();
    skipText = null;

    for (obj in [fakeBoyfriend, fakeGirlfriend, picoCutscene])
    {
      if (obj == null) continue;
      obj.destroy();
      obj = null;
    }

    tankmanCutscene.destroy();
    tankmanCutscene = null;

    if (PlayState.instance.subtitles != null)
    {
      PlayState.instance.subtitles.assignedSound = null;
      PlayState.instance.subtitles.subtitlesData = null;
      PlayState.instance.subtitles.setText([], true);
    }

    PlayState.instance.currentStage.getDad().visible = true;
    PlayState.instance.currentStage.getGirlfriend().visible = true;
    PlayState.instance.currentStage.getBoyfriend().visible = true;
    PlayState.instance.currentStage.getBoyfriend().dance(true);

    var tankman:StageProp = PlayState.instance.currentStage.getNamedProp('tankmanAudience3');
    if (tankman != null) tankman.visible = true;

    PlayState.instance.isInCutscene = false;
    PlayState.instance.mayPauseGame = true;
    PlayState.instance.startCountdown();
  }

  function setupCharacter(character:BaseCharacter, charType:CharacterType):Void
  {
    var stageCharData:StageDataCharacter = null;
    switch (charType)
    {
      case CharacterType.BF:
        stageCharData = PlayState.instance.currentStage._data.characters.bf;
        character.flipX = !character.getDataFlipX();
      case CharacterType.GF:
        stageCharData = PlayState.instance.currentStage._data.characters.gf;
        character.flipX = character.getDataFlipX();
      case CharacterType.DAD:
        stageCharData = PlayState.instance.currentStage._data.characters.dad;
        character.flipX = character.getDataFlipX();
    }

    character.resetCharacter(true);

    if (stageCharData == null) return;

    character.zIndex = stageCharData.zIndex;

    character.x = stageCharData.position[0] - character.characterOrigin.x;
    character.y = stageCharData.position[1] - character.characterOrigin.y;
    character.originalPosition.set(character.x, character.y);

    var finalScale = character.getBaseScale() * stageCharData.scale;
    character.setScale(finalScale); // Don't use scale.set for characters!
    character.cameraFocusPoint.x += stageCharData.cameraOffsets[0];
    character.cameraFocusPoint.y += stageCharData.cameraOffsets[1];

    character.scrollFactor.x = stageCharData.scroll[0];
    character.scrollFactor.y = stageCharData.scroll[1];

    character.alpha = stageCharData.alpha;
    character.angle = stageCharData.angle;
  }

  function onUpdate(event:UpdateScriptEvent)
  {
    super.onUpdate(event);

    if (cutsceneTimerManager != null)
    {
      cutsceneTimerManager.update(event.elapsed);
    }

    if (cutsceneTimeDummy != null)
    {
      cutsceneTimeDummy.time += event.elapsed * 1000;
    }

    if (cutsceneConductor != null && cutsceneMusic != null)
    {
      cutsceneConductor.update(cutsceneMusic.time);
    }

    if (FlxG.onMobile)
    {
      isMobilePauseButtonPressed = TouchUtil.overlapsComplex(PlayState.instance.pauseButton) && TouchUtil.justPressed;
    }

    if ((PlayState.instance.controls.CUTSCENE_ADVANCE || isMobilePauseButtonPressed) && !cutsceneSkipped)
    {
      if (!canSkipCutscene)
      {
        trace('Can\'t skip cutscene yet!');
        if (skipText != null)
        {
          FlxTween.tween(skipText, {alpha: 1}, 0.5, {ease: FlxEase.quadOut});
          new FlxTimer().start(0.5, _ -> {
            canSkipCutscene = true;
            trace('Can skip cutscene!');
          });
        }
      }
    }
    if ((PlayState.instance.controls.CUTSCENE_ADVANCE || isMobilePauseButtonPressed) && !cutsceneSkipped && canSkipCutscene)
    {
      skipCutscene();
      trace('Skipped cutscene!');
    }
  }

  function onCutsceneStepHit():Void
  {
    var event:SongTimeScriptEvent = new SongTimeScriptEvent("SONG_STEP_HIT", cutsceneConductor.currentBeat, cutsceneConductor.currentStep);

    if (fakeGirlfriend != null)
    {
      ScriptEventDispatcher.callEvent(fakeGirlfriend, event);
    }
  }

  function onCutsceneBeatHit():Void
  {
    var event:SongTimeScriptEvent = new SongTimeScriptEvent("SONG_BEAT_HIT", cutsceneConductor.currentBeat, cutsceneConductor.currentStep);

    if (fakeGirlfriend != null)
    {
      ScriptEventDispatcher.callEvent(fakeGirlfriend, event);
    }
  }

  function onSongRetry(event:ScriptEvent)
  {
    super.onSongRetry(event);

    hasPlayedCutscene = true;

    if (PlayState.instance.currentStage.scriptGet('storm0').alpha > 0 && !RemnantsOptions.getPerformanceOption()) 
    PlayState.instance.currentStage.stormOff(1);

    // resets the tankmen!
    if (tankmanGroup != null)
    {
      tankmanGroup.scriptCall('reset');
    }
  }

  function onGameOver(event:ScriptEvent):Void
  {
    super.onGameOver(event);

    if (PlayState.instance.currentStage.scriptGet('storm0').alpha > 0 && !RemnantsOptions.getPerformanceOption()) 
    PlayState.instance.currentStage.stormOff(0);
  }

  function kill():Void
  {
    cleanupTankmanGroup();
  }

  function cleanupTankmanGroup():Void
  {
    if (tankmanGroup != null)
    {
      PlayState.instance.currentStage.remove(tankmanGroup);
      tankmanGroup.destroy();
      tankmanGroup = null;
    }
  }

  function onBeatHit(event:SongTimeScriptEvent):Void
  {
    super.onBeatHit(event);

    if (PlayState.instance.isGameOverState || RemnantsOptions.getPerformanceOption()) return;
    switch (event.beat)
    {
      case 96:
        PlayState.instance.currentStage.stormOn(1);
      case 160:
        PlayState.instance.currentStage.stormOff(1);
      case 224:
        PlayState.instance.currentStage.stormOn(1);
    }
  }
}
