import flixel.effects.FlxFlicker;
import flixel.FlxG;
import flixel.group.FlxTypedSpriteGroup;
import flixel.tweens.FlxTween;
import flixel.util.FlxTimer;
import funkin.audio.FunkinSound;
import funkin.graphics.FunkinSprite;
import funkin.modding.base.ScriptedFunkinSprite;
import funkin.modding.module.ModuleHandler;
import funkin.play.character.CharacterType;
import flixel.graphics.FlxGraphic;
import funkin.play.character.MultiAnimateAtlasCharacter;
import funkin.play.GameOverSubState;
import funkin.play.PauseSubState;
import funkin.play.PlayState;
import funkin.util.Constants;
import funkin.util.HapticUtil;
import funkin.Preferences;
import funkin.FunkinMemory;

using StringTools;

class PicoRemnantsPlayerCharacter extends MultiAnimateAtlasCharacter
{
  function new()
  {
    super('pico-remnants-playable');
    ignoreExclusionPref.push("shoot");
    ignoreExclusionPref.push("fire");
  }

  function onCreate(event:ScriptEvent)
  {
    super.onCreate(event);

    // NOTE: this.x and this.y are not properly set here.

    GameOverSubState.musicSuffix = '-remnants-pico';
    GameOverSubState.blueBallSuffix = '-pico';
    GameOverSubState.animationSuffix = "";

    PauseSubState.musicSuffix = '-remnants-pico';

    // Precache images and sounds.
    var imgs:Array<String> = [
      "characters/neneKnife-remnants",
      "shared:characters/pico-remnants/explosion-death/spritemap1",
      "weekend1:remnants/spraycans/PicoBullet"
    ];

    var snds:Array<String> = ["singed_loop", "Gun_Prep", "Pico_Bonk", "shot1", "shot2", "shot3", "shot4"];

    for (img in imgs)
    {
      var lib:String = Paths.getLibrary(img);
      var file:String = Paths.stripLibrary(img);

      // We don't need these graphics outside of Weekend 1.
      if (lib == "weekend1" && Paths.currentLevel != "weekend1")
      {
        continue;
      }

      FunkinMemory.cacheTexture(Paths.image(file, lib == 'preload' ? null : lib));
    }

    // We don't need these sounds outside of Weekend 1.
    if (Paths.currentLevel == "weekend1")
    {
      for (snd in snds)
      {
        FunkinMemory.cacheSound(Paths.sound(snd, "weekend1"));
      }
    }
  }

  var deathSpriteNene:FunkinSprite;

  /**
     * Initialize and cache sprites used for the death animation,
   * for use later.
   */
  function createDeathSprites()
  {
    deathSpriteNene = FunkinSprite.createSparrow(0, 0, "characters/neneKnife-remnants");
    var gf = PlayState.instance?.currentStage.getGirlfriend();
    deathSpriteNene.x = gf.originalPosition.x + 120;
    deathSpriteNene.y = gf.originalPosition.y;
    deathSpriteNene.zIndex = this.zIndex - 5;
    deathSpriteNene.animation.addByPrefix('throw', "knife toss0", 24, false);
    deathSpriteNene.visible = true;
    deathSpriteNene.animation.onFinish.add(function(name:String) {
      deathSpriteNene.visible = false;
    });
  }

  function onNoteHit(event:HitNoteScriptEvent)
  {
    if (event.eventCanceled)
    {
      // onNoteHit event was cancelled by the gameplay module.
      return;
    }

    // Override the hit note animation.
    switch (event.note.kind)
    {
      case "hey":
        holdTimer = 0;
        this.playAnimation('hey', true, true);
        return;
      case "cheer":
        holdTimer = 0;
        this.playAnimation('cheer', true, true);
        return;
      case "censor":
        holdTimer = 0;
        this.playSingAnimation(event.note.noteData.getDirection(), false, 'censor');
        return;
      case "perfect":
        holdTimer = 0;
        this.playSingAnimation(event.note.noteData.getDirection(), false, 'perfect');
      case "weekend-1-cockgun": // HE'S PULLING HIS COCK OUT
        holdTimer = 0;
        playCockGunAnim();
      case "weekend-1-firegun":
        holdTimer = 0;
        playFireGunAnim();
      default:
        super.onNoteHit(event);
    }
  }

  function onNoteMiss(event:NoteScriptEvent)
  {
    // Override the miss note animation.
    switch (event.note.kind)
    {
      case "weekend-1-cockgun":
        // playCockMissAnim();
      case "weekend-1-firegun":
        playCanExplodeAnim();
      default:
        super.onNoteMiss(event);
    }
  }

  function playAnimation(name:String, restart:Bool, ignoreOther:Bool)
  {
    // restore vocal volume to ensure burps always play
    // not needed on the dark variant because this one always exists anyway..
    if (name == "hey" || name == "cheer" || name == "burpSmile" || name == "burpSmileLong" || name == "burpShit") PlayState.instance?.vocals?.playerVolume = 1;

    // Bugfix!
    if (["firstDeath", "deathLoop", "deathConfirm"].contains(name) && GameOverSubState.animationSuffix.length > 0)
    {
      return playAnimation(name + GameOverSubState.animationSuffix, restart, ignoreOther);
    }

    if (name == "firstDeath")
    {
      // Standard death animation.
      createDeathSprites();

      GameOverSubState.instance.add(deathSpriteNene);
      deathSpriteNene.animation.play("throw");
    }

    if (name == "firstDeath-explosion")
    {
      // Explosion death animation.
      doExplosionDeath();
    }
    else if (name == "deathConfirm-explosion")
    {
      doExplosionConfirm();
    }

    super.playAnimation(name, restart, ignoreOther);
  }

  var picoFlicker:FlxFlicker = null;

  override function onAnimationFinished(name:String)
  {
    super.onAnimationFinished(name);

    if (name == 'shootMISS' && PlayState.instance.health > 0.0 && !PlayState.instance.isPlayerDying)
    {
      // ERIC: You have to use super instead of this or it breaks.
      // This is because typeof(this) is PolymodAbstractClass.
      picoFlicker = FlxFlicker.flicker(super, 1, 1 / 30, true, true, function(_) {
        picoFlicker = FlxFlicker.flicker(super, 0.5, 1 / 60, true, true, function(_) {
          picoFlicker = null;
        });
      });
    }

    if (name == 'firstDeath-explosion')
    {
      playAnimation('deathLoop-explosion', true);
    }
  }

  public override function onPause(event:PauseScriptEvent)
  {
    super.onPause(event);

    if (fadeTween != null) fadeTween.active = false;
    if (picoFlicker != null)
    {
      picoFlicker.pause();
      this.visible = true;
    }
  }

  public override function onResume(event:ScriptEvent)
  {
    super.onResume(event);

    if (fadeTween != null) fadeTween.active = true;
    if (picoFlicker != null)
    {
      picoFlicker.resume();
    }
  }

  function doExplosionDeath():Void
  {
    if (picoFlicker != null)
    {
      picoFlicker.stop(); // this sets visible to true, but we make it false a few lines down anyways
    }

    // Suffixed death sound will already play.
    GameOverSubState.instance.targetCameraZoom = 0.8;

    // Move the camera to center pico.
    GameOverSubState.instance.cameraFollowPoint.x += 50;

    HapticUtil.vibrate(0, 0.5);

    // Death by Darnell's can.
    new FlxTimer().start(1.85, function(tmr:FlxTimer) {
      // Pico falls on his knees.
      HapticUtil.vibrate(0, 0.1, 0.1, 1);
    });

    new FlxTimer().start(3.0, afterPicoDeathExplosionIntro);
  }

  var singed:FunkinSound;

  function afterPicoDeathExplosionIntro(timer:FlxTimer):Void
  {
    // Start the (standard) death music, 3.5 seconds after the explosion starts,
    // not when the explosion sound finishes or when the loop starts.
    GameOverSubState.instance.startDeathMusic(1.0, false);
    singed = FunkinSound.load(Paths.sound('singed_loop'), true, false, true);
    // singed.fadeIn(0.5, 0.3, 1.0);
  }

  function doExplosionConfirm():Void
  {
    if (singed != null)
    {
      singed.stop();
      singed = null;
    }
  }

  override function onSongRetry(event:ScriptEvent):Void
  {
    super.onSongRetry(event);

    // Don't let these pile up.
    clearCasings();

    // Reset to standard death animation.
    GameOverSubState.musicSuffix = '-remnants-pico';
    GameOverSubState.blueBallSuffix = '-pico';
    GameOverSubState.animationSuffix = "";
    PauseSubState.musicSuffix = '-remnants-pico';
  }

  function onAnimationFrame(name:String, frameNumber:Int, frameIndex:Int)
  {
    super.onAnimationFrame(name, frameNumber, frameIndex);

    if (name == "firstDeath" && frameNumber == 36 - 1)
    {
      GameOverSubState.instance.startDeathMusic(1.0, false);
      // force the deathloop to play in here, since we are starting the music early it
      // doesn't check this in gameover substate !
      // also no animation suffix ðŸ¤”
      playAnimation('deathLoop');
    }

    if (name == "cock" && frameNumber == 3)
    {
      createCasing();
    }

    if (!HapticUtil.hapticsAvailable) return;

    // Pico falls on his back.
    if (name == 'firstDeath' && frameNumber == 20)
    {
      HapticUtil.vibrate(0, 0.1, 0.1, 1);
    }

    // Blood firework woohoo!!!!
    if (name == 'deathLoop' && frameNumber % 2 == 0)
    {
      final randomAmplitude:Float = FlxG.random.float(0.1, 0.5);
      final randomDuration:Float = FlxG.random.float(0.1, 0.3);

      HapticUtil.vibrate(0, randomDuration, randomAmplitude);
    }
  }

  var casingGroup:FlxTypedSpriteGroup;

  function createCasing():Void
  {
    if (casingGroup == null)
    {
      casingGroup = new FlxTypedSpriteGroup();
      casingGroup.x = this.x + 250;
      casingGroup.y = this.y + 100;
      casingGroup.zIndex = 1000;
      addToStage(casingGroup);
    }

    var casing = ScriptedFunkinSprite.init('CasingSpriteRemnants', 0, 0);
    if (casing != null) casingGroup.add(casing);
  }

  function clearCasings():Void
  {
    // Clear the casing group.
    if (casingGroup != null)
    {
      casingGroup.clear();
      casingGroup = null;
    }
  }

  var picoFade:FunkinSprite;
  var fadeTween:FlxTween;

  function playCockGunAnim():Void
  {
    this.playAnimation('cock', true, true);
    FunkinSound.playOnce(Paths.sound('Gun_Prep'), 1);

    if (debug) return;
    if (picoFade != null) picoFade.destroy();
    picoFade = new FunkinSprite(this.x - 50, this.y);
    picoFade.x -= this.animOffsets[0] + this.globalOffsets[0];
    picoFade.y -= this.animOffsets[1] + this.globalOffsets[1];
    picoFade.pixels = updateFramePixels();
    picoFade.updateHitbox();
    picoFade.alpha = 0.3;
    picoFade.zIndex = this.zIndex - 3;
    PlayState.instance?.currentStage?.add(picoFade);
    PlayState.instance?.currentStage?.refresh();

    if (fadeTween != null) fadeTween.cancel();
    fadeTween = FlxTween.num(0, 1, 0.4,
      {
        onComplete: (_) -> {
          fadeTween = null;
        }
      }, (num:Float) -> {
        picoFade.scale.set(1 + (0.3 * num), 1 + (0.3 * num));
        picoFade.alpha = 0.3 - (0.3 * num);
      });
  }

  /**
   * Play the animations where Pico shoots the can successfully.
   */
  function playFireGunAnim(hip:Bool):Void
  {
    if (FlxG.random.bool(50))
    {
      this.playAnimation('shoot', true, true);
    }
    else
    {
      this.playAnimation('fire', true, true);
    }

    FunkinSound.playOnce(Paths.soundRandom('shot', 1, 4));
  }

  /**
   * Play the animation where Pico is hit by the exploding can.
   */
  function playCanExplodeAnim():Void
  {
    this.playAnimation('shootMISS', true, true);
    // Donk.
    FunkinSound.playOnce(Paths.sound('Pico_Bonk'), 1.0);
  }

  function addToStage(sprite:FunkinSprite):Void
  {
    if (this.debug)
    {
      // We are in the chart editor or something.
      // TODO: Make this work properly.
    }
    else if (PlayState.instance?.currentStage != null)
    {
      PlayState.instance.currentStage.add(sprite);
    }
    else
    {
      trace('Could not add Pico sprite to stage.');
    }
  }

  function getDeathQuote():Null<String>
  {
    switch (PlayState.instance?.currentStage?.getDad()?.characterId)
    {
      case "tankman":
        var randomCensor:Array<Int> = [];

        if (!Preferences.naughtyness)
        {
          // 4 - fucking
          // 7 - goddamn, ass
          // 8 - fuck
          // 9 - ass, bitch
          randomCensor = [4, 7, 8, 9];
        }
        else if (Constants.CENSOR_EXPLETIVES)
        {
          randomCensor = [4, 8];
        }

        return Paths.sound('jeffGameover-pico/jeffGameover-' + FlxG.random.int(1, 10, randomCensor));
      default:
        return null;
    }
  }
}
