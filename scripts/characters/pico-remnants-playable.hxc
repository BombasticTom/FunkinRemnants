import flixel.effects.FlxFlicker;
import flixel.FlxG;
import flixel.FlxSprite;
import flixel.group.FlxTypedSpriteGroup;
import flixel.tweens.FlxTween;
import flixel.tweens.FlxEase;
import flixel.util.FlxTimer;
import funkin.audio.FunkinSound;
import funkin.graphics.FunkinSprite;
import funkin.modding.base.ScriptedFunkinSprite;
import funkin.modding.module.ModuleHandler;
import funkin.play.character.CharacterType;
import funkin.play.character.MultiSparrowCharacter;
import funkin.play.GameOverSubState;
import funkin.play.PauseSubState;
import funkin.play.PlayState;
import funkin.util.Constants;
import funkin.util.HapticUtil;
import funkin.Preferences;
import funkin.FunkinMemory;

using StringTools;

class PicoRemnantsPlayerCharacter extends MultiSparrowCharacter
{
  function new()
  {
    super('pico-remnants-playable');
    ignoreExclusionPref.push("shoot");
  }

  function onCreate(event:ScriptEvent)
  {
    super.onCreate(event);

    // NOTE: this.x and this.y are not properly set here.

    GameOverSubState.musicSuffix = '-remnants-pico';
    GameOverSubState.blueBallSuffix = '-pico';
    GameOverSubState.animationSuffix = "";

    PauseSubState.musicSuffix = '-remnants-pico';

    // Precache images and sounds.
    var imgs:Array<String> = [
      "characters/Pico_Death_Retry-remnants",
      "characters/neneKnife-remnants",
      "shared:characters/picoExplosionDeath-remnants/spritemap1",
      "weekend1:remnants/spraycans/PicoBullet"
    ];

    var snds:Array<String> = ["singed_loop", "Gun_Prep", "Pico_Bonk", "shot1", "shot2", "shot3", "shot4"];

    for (img in imgs)
    {
      var lib:String = Paths.getLibrary(img);
      var file:String = Paths.stripLibrary(img);

      FunkinMemory.cacheTexture(Paths.image(file, lib == 'preload' ? null : lib));
    }

    for (snd in snds)
    {
      FunkinMemory.cacheSound(Paths.sound(snd, "weekend1"));
    }
  }

  var deathSpriteRetry:FunkinSprite;
  var deathSpriteNene:FunkinSprite;
  var loseSprite:FunkinSprite;
  var picoFade:FunkinSprite;

  /**
   * Initialize and cache sprites used for the death animation,
   * for use later.
   */
  function createDeathSprites()
  {
    deathSpriteRetry = FunkinSprite.createSparrow(0, 0, "characters/Pico_Death_Retry-remnants");

    // week 3 shader
    if (shader != null)
    {
      deathSpriteRetry.shader = shader;
    }

    // Reminder: The position for this is set in `onAnimationFrame`
    deathSpriteRetry.animation.addByPrefix('idle', "Retry Text Loop0", 24, true);
    deathSpriteRetry.animation.addByPrefix('confirm', "Retry Text Confirm0", 24, false);
    deathSpriteRetry.zIndex = this.zIndex + 5;
    deathSpriteRetry.visible = false;

    deathSpriteNene = FunkinSprite.createSparrow(0, 0, "characters/neneKnife-remnants");
    var gf = PlayState.instance.currentStage.getGirlfriend();
    deathSpriteNene.x = gf.originalPosition.x + 120;
    deathSpriteNene.y = gf.originalPosition.y - 200;
    deathSpriteNene.zIndex = this.zIndex - 5;
    deathSpriteNene.animation.addByPrefix('throw', "knife toss0", 24, false);
    deathSpriteNene.visible = true;
    deathSpriteNene.animation.onFinish.add(function(name:String) {
      deathSpriteNene.visible = false;
    });

    loseSprite = FunkinSprite.createSparrow(1750, 300, "gameover/loseText");

    // week 3 shader
    if (shader != null)
    {
      loseSprite.shader = shader;
    }

    loseSprite.animation.addByPrefix('fall', "lose0", 24, false);
    loseSprite.animation.addByPrefix('idle', "lose loop0", 24, true);
    loseSprite.animation.onFinish.add(function(name:String) {
      loseSprite.animation.play('idle', true);
    });

    loseSprite.zIndex = this.zIndex + 5;
    loseSprite.visible = false;
  }

  function onNoteHit(event:HitNoteScriptEvent)
  {
    if (event.eventCanceled)
    {
      // onNoteHit event was cancelled by the gameplay module.
      return;
    }

    // Override the hit note animation.
    switch (event.note.kind)
    {
      case "hey":
        holdTimer = 0;
        this.playAnimation('hey', true, true);
        return;
      case "cheer":
        holdTimer = 0;
        this.playAnimation('cheer', true, true);
        return;
      case "censor":
        holdTimer = 0;
        this.playSingAnimation(event.note.noteData.getDirection(), false, 'censor');
        return;
      case "perfect":
        holdTimer = 0;
        this.playSingAnimation(event.note.noteData.getDirection(), false, 'perfect');
      case "weekend-1-cockgun": // HE'S PULLING HIS COCK OUT
        holdTimer = 0;
        playCockGunAnim();
      case "weekend-1-firegun":
        holdTimer = 0;
        playFireGunAnim();
      default:
        super.onNoteHit(event);
    }
  }

  function onNoteMiss(event:NoteScriptEvent)
  {
    // Override the miss note animation.
    switch (event.note.kind)
    {
      case "weekend-1-cockgun":
        // playCockMissAnim();
      case "weekend-1-firegun":
        playCanExplodeAnim();
      default:
        super.onNoteMiss(event);
    }
  }

  function playAnimation(name:String, restart:Bool, ignoreOther:Bool)
  {
    // restore vocal volume to ensure burps always play
    // not needed on the dark variant because this one always exists anyway..
    if (name == "hey" || name == "cheer" || name == "burpSmile" || name == "burpSmileLong" || name == "burpShit") PlayState.instance?.vocals?.playerVolume = 1;

    // Bugfix!
    if (["firstDeath", "deathLoop", "deathConfirm"].contains(name) && GameOverSubState.animationSuffix.length > 0)
    {
      return playAnimation(name + GameOverSubState.animationSuffix, restart, ignoreOther);
    }

    if (!this.debug)
    {
      switch(name)
      {
        case "firstDeath":
          // Lose...
          createDeathSprites();
          GameOverSubState.instance.add(loseSprite);

          GameOverSubState.instance.add(deathSpriteRetry);
          GameOverSubState.instance.add(deathSpriteNene);
          deathSpriteNene.animation.play("throw");

        case "deathConfirm":
          if (loseSprite != null)
          {
            FlxTween.tween(loseSprite, {alpha: 0}, 1, {ease: FlxEase.quadInOut});
          }

          if (deathSpriteRetry != null)
          {
            deathSpriteRetry.animation.play('confirm');
            // I think the glow makes the overall animation larger,
            // but a plain FlxSprite doesn't have an animation offset option so we do it manually.
            deathSpriteRetry.x -= 250;
            deathSpriteRetry.y -= 200;
          }

          // Skip playing the animation.
          return;

        case "firstDeath-explosion":
          doExplosionDeath();
          return;

        case "deathConfirm-explosion":
          doExplosionConfirm();
          return;
      }
    }

    super.playAnimation(name, restart, ignoreOther);
  }

  var picoFlicker:FlxFlicker = null;

  override function onAnimationFinished(name:String)
  {
    super.onAnimationFinished(name);

    if (name == 'shootMISS' && PlayState.instance.health > 0.0 && !PlayState.instance.isPlayerDying)
    {
      // ERIC: You have to use super instead of this or it breaks.
      // This is because typeof(this) is PolymodAbstractClass.
      picoFlicker = FlxFlicker.flicker(super, 1, 1 / 30, true, true, function(_) {
        picoFlicker = FlxFlicker.flicker(super, 0.5, 1 / 60, true, true, function(_) {
          picoFlicker = null;
        });
      });
    }
  }

  public override function onPause(event:PauseScriptEvent)
  {
    super.onPause(event);

    if (picoFlicker != null)
    {
      picoFlicker.pause();
      this.visible = true;
    }
  }

  public override function onResume(event:ScriptEvent)
  {
    super.onResume(event);

    if (picoFlicker != null)
    {
      picoFlicker.resume();
    }
  }

  public override function getDeathCameraOffsets():Array<Float>
  {
    var result = super.getDeathCameraOffsets();

    if (GameOverSubState.blueBallSuffix == '-pico-explode-remnants')
    {
      return [result[0] - 725, result[1] + 175];
    }

    return [result[0], result[1]];
  }

  var picoDeathExplosion:FunkinSprite;

  function doExplosionDeath()
  {
    if (picoFlicker != null)
    {
      picoFlicker.stop(); // this sets visible to true, but we make it false a few lines down anyways
    }

    // Suffixed death sound will already play.
    GameOverSubState.instance.resetCameraZoom();
    GameOverSubState.instance.targetCameraZoom = 0.8;

    // Move the camera up.
    GameOverSubState.instance.cameraFollowPoint.y -= 100;

    HapticUtil.vibrate(0, 0.5);

    // Death by Darnell's can.
    new FlxTimer().start(1.85, function(tmr:FlxTimer) {
      // Pico falls on his knees.
      HapticUtil.vibrate(0, 0.1, 0.1, 1);
    });

    picoDeathExplosion = FunkinSprite.createTextureAtlas(this.x - 1100, this.y - 1000, "characters/picoExplosionDeath-remnants", "shared");
    PlayState.instance.subState.add(picoDeathExplosion);
    picoDeathExplosion.zIndex = 1000;
    picoDeathExplosion.anim.onFinish.add(onExplosionFinishAnim);
    picoDeathExplosion.visible = true;
    this.visible = false;

    new FlxTimer().start(3.0, afterPicoDeathExplosionIntro);

    picoDeathExplosion.anim.play('intro');
  }

  var singed:FunkinSound;

  function afterPicoDeathExplosionIntro(timer:FlxTimer)
  {
    // Start the (standard) death music, 3.5 seconds after the explosion starts,
    // not when the explosion sound finishes or when the loop starts.
    GameOverSubState.instance.startDeathMusic(1.0, false);
    singed = FunkinSound.load(Paths.sound('singed_loop'), true, false, true);
    // singed.fadeIn(0.5, 0.3, 1.0);
  }

  function doExplosionConfirm()
  {
    // Suffixed confirm music will already play.
    picoDeathExplosion.anim.play('Confirm');
    if (singed != null)
    {
      singed.stop();
      singed = null;
    }
  }

  function onExplosionFinishAnim(animLabel:String)
  {
    if (animLabel == 'intro')
    {
      picoDeathExplosion.anim.play('Loop Start', true);
      picoDeathExplosion.anim.curAnim.looped = true;
    }
    else if (animLabel == 'Confirm')
    {
      // Do nothing, the animation will just play.
    }
    trace("Explosion animation finished: " + animLabel);
  }

  override function onGameOver(event:ScriptEvent):Void
  {
    super.onGameOver(event);
  }

  override function onSongRetry(event:ScriptEvent):Void
  {
    super.onSongRetry(event);

    // Don't let these pile up.
    clearCasings();

    // Reset to standard death animation.
    GameOverSubState.musicSuffix = '-remnants-pico';
    GameOverSubState.blueBallSuffix = '-pico';
    GameOverSubState.animationSuffix = "";
    PauseSubState.musicSuffix = '-remnants-pico';

    picoDeathExplosion = null;
    this.visible = true;
  }

  function onAnimationFrame(name:String, frameNumber:Int, frameIndex:Int)
  {
    super.onAnimationFrame(name, frameNumber, frameIndex);

    if (name.startsWith("firstDeath") && frameNumber == 36 - 1)
    {
      if (deathSpriteRetry != null && deathSpriteRetry.animation != null)
      {
        deathSpriteRetry.animation.play('idle');
        deathSpriteRetry.visible = true;

        deathSpriteRetry.x = this.x + 195;
        deathSpriteRetry.y = this.y - 70;
      }

      GameOverSubState.instance.startDeathMusic(1.0, false);
      // force the deathloop to play in here, since we are starting the music early it
      // doesn't check this in gameover substate !
      // also no animation suffix ????
      GameOverSubState.instance.boyfriend.playAnimation('deathLoop' + GameOverSubState.animationSuffix);

      if (name != 'firstDeath-explosion' && loseSprite != null)
      {
        loseSprite.visible = true;
        loseSprite.animation.play('fall', true);
      }
    }

    if (name == "cock" && frameNumber == 3)
    {
      createCasing();
    }

    if (!HapticUtil.hapticsAvailable) return;

    // Pico falls on his back.
    if (name == 'firstDeath' && frameNumber == 20)
    {
      HapticUtil.vibrate(0, 0.1, 0.1, 1);
    }

    // Blood firework woohoo!!!!
    if (name == 'deathLoop' && frameNumber % 2 == 0)
    {
      final randomAmplitude:Float = FlxG.random.float(0.1, 0.5);
      final randomDuration:Float = FlxG.random.float(0.1, 0.3);

      HapticUtil.vibrate(0, randomDuration, randomAmplitude);
    }
  }

  var casingGroup:FlxTypedSpriteGroup;

  function createCasing()
  {
    if (casingGroup == null)
    {
      casingGroup = new FlxTypedSpriteGroup();
      casingGroup.x = this.x + 250;
      casingGroup.y = this.y + 100;
      casingGroup.zIndex = 1000;
      addToStage(casingGroup);
    }

    var casing = ScriptedFunkinSprite.init('CasingSpriteRemnants', 0, 0);
    if (casing != null) casingGroup.add(casing);
  }

  function clearCasings()
  {
    // Clear the casing group.
    if (casingGroup != null)
    {
      casingGroup.clear();
      casingGroup = null;
    }
  }

  /**
   * Play the animation where Pico readies his gun to shoot the can.
   */
  function playCockGunAnim()
  {
    this.playAnimation('cock', true, true);

    picoFade = new FlxSprite(0, 0);
    picoFade.frames = this.frames;
    picoFade.frame = this.frame;
    picoFade.updateHitbox();
    picoFade.x = this.x;
    picoFade.y = this.y;
    // picoFade.stamp(this, 0, 0);
    picoFade.alpha = 0.3;
    picoFade.zIndex = this.zIndex - 3;
    addToStage(picoFade);
    FlxTween.tween(picoFade.scale, {x: 1.3, y: 1.3}, 0.4);
    FlxTween.tween(picoFade, {alpha: 0}, 0.4);

    FunkinSound.playOnce(Paths.sound('Gun_Prep'), 1.0);
  }

  /**
   * Play the animation where Pico shoots the can successfully.
   */
  function playFireGunAnim(hip:Bool)
  {
    this.playAnimation('shoot', true, true);
    FunkinSound.playOnce(Paths.soundRandom('shot', 1, 4));
  }

  /**
   * Play the animation where Pico is hit by the exploding can.
   */
  function playCanExplodeAnim()
  {
    this.playAnimation('shootMISS', true, true);
    // Donk.
    FunkinSound.playOnce(Paths.sound('Pico_Bonk'), 1.0);
  }

  function addToStage(sprite:FlxSprite)
  {
    if (this.debug)
    {
      // We are in the chart editor or something.
      // TODO: Make this work properly.
    }
    else if (PlayState.instance != null && PlayState.instance.currentStage != null)
    {
      PlayState.instance.currentStage.add(sprite);
    }
    else
    {
      trace('Could not add Pico sprite to stage.');
    }
  }

  function getDeathQuote():Null<String>
  {
    switch (PlayState.instance?.currentStage?.getDad()?.characterId)
    {
      case "tankman":
        var randomCensor:Array<Int> = [];

        if (!Preferences.naughtyness)
        {
          // 4 - fucking
          // 7 - goddamn, ass
          // 8 - fuck
          // 9 - ass, bitch
          randomCensor = [4, 7, 8, 9];
        }
        else if (Constants.CENSOR_EXPLETIVES)
        {
          randomCensor = [4, 8];
        }

        return Paths.sound('jeffGameover-pico/jeffGameover-' + FlxG.random.int(1, 10, randomCensor));
      default:
        return null;
    }
  }
}
