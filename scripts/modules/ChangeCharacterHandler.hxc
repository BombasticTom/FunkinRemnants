// Coded by NebulaStellaNova

import funkin.play.character.CharacterDataParser;
import funkin.play.character.CharacterType;
import funkin.modding.module.Module;
import funkin.play.song.Song;
import funkin.play.PlayState;
import Reflect;

class ChangeCharacterModule extends Module {

	// Cached character list.
	var characterCaches = [
		"bf" => [ "init" => true ],
		"gf" => [ "init" => true ],
		"dad" => [ "init" => true ]
	];

	// Character types using a string, probably exists in a class in the source but I don't want to find it.
	var types = [
		"bf" => CharacterType.BF,
		"gf" => CharacterType.GF,
		"dad" => CharacterType.DAD
	];

	// Call the constructor (Useless comment lol)
	function new() {
		super("ChangeCharacterModule");
	}

	override function onSongEvent(event) {
		super.onSongEvent(event);
		var theEvent = event.eventData;
		if (theEvent.eventKind == "ChangeCharacter") {
			if (CharacterDataParser.listCharacterIds().contains(theEvent.value.newchar.toLowerCase())) {
				
				// Grab the new character from the cached characters.
				var theCharacter = characterCaches.get(theEvent.value.character).get(theEvent.value.newchar.toLowerCase());
				
				if (theCharacter != null) {
				
					// Get the character that we will be replacing using the type in the event parameters.
					var targetPos = [
						"bf" => PlayState.instance.currentStage.getBoyfriend(),
						"gf" => PlayState.instance.currentStage.getGirlfriend(),
						"dad" => PlayState.instance.currentStage.getDad()
					].get(theEvent.value.character);

					// Grab the data from the old character just to be safe.
					var targetX = targetPos.x;
					var targetY = targetPos.y;
					var targetZIndex = targetPos.zIndex;
					
					// Kill the old character so it's not longer on the stage.
					targetPos.kill();
					
					// Revive the new character incase it was killed during a previous event call.
					theCharacter.revive();
					theCharacter.x = targetX;
					theCharacter.y = targetY;
					theCharacter.zIndex = targetZIndex;
					
					// Add the new character to the current stage, then refresh the stage so the zIndex gets applied.
					PlayState.instance.currentStage.addCharacter(theCharacter, types.get(theEvent.value.character));
					PlayState.instance.currentStage.refresh();
					
					// Initiate the health icon if either bf or dad.
					if (theEvent.value.character != "gf")
						theCharacter.initHealthIcon(theEvent.value.character == "dad");

				}
			} else {
				
				// If the character doesn't exist, tell the modder.
				trace("Unkown Character \"" + theEvent.value.newchar + "\"");
				
			}
		}
	}

	override function onCountdownStart(event) {
		super.onCountdownStart(event);

		// List of characters that don't actually exist but are called for in the event.
		var unknownCharacters = [];
		
		for (i in PlayState.instance.songEvents) {
			if (i.eventKind == "ChangeCharacter") {
				if (CharacterDataParser.listCharacterIds().contains(i.value.newchar.toLowerCase())) {
					// Get the character we are precaching using it's ID from the event.
					var exCharacter = CharacterDataParser.fetchCharacter(i.value.newchar.toLowerCase());
					
					// Add the character to the precached list.
					characterCaches.get(i.value.character).set(i.value.newchar.toLowerCase(), exCharacter);
				} else {
					// If the character ID in the event doesn't have a corresponding character in the registry, add to list of unknowns. 
					unknownCharacters.push(i.value.newchar);
				}
			}
		}

		// List all the characters that where not found.
		for (i in unknownCharacters)
			trace("Unkown Character \"" + i + "\"");
		
		trace("Character Caching Finished!");
	}

	override function onSongRetry(event) {
		super.onSongRetry(event);

		// Destory all existing caches
		for (a in ["bf", "gf", "dad"]) {
			for (i in characterCaches.get(a)) {
				if (i != true) {
					i.destroy();
				}
			}
		}

		// Clear the cached character list.
		characterCaches = [
			"bf" => [ "init" => true ],
			"gf" => [ "init" => true ],
			"dad" => [ "init" => true ]
		];
		

		// Get the original character list from the beginning of the song.
		var defaultChararcters = PlayState.instance.currentSong.difficulties.get(PlayState.instance.currentVariation).get(PlayState.instance.currentDifficulty).characters;
		
		// Reset boyfriend to the original character.
		if (PlayState.instance.currentStage.getBoyfriend() != null) {
			var exCharacter = CharacterDataParser.fetchCharacter(defaultChararcters.player);
			PlayState.instance.currentStage.getBoyfriend().destroy();
			PlayState.instance.currentStage.addCharacter(exCharacter, types.get("bf"));
			exCharacter.initHealthIcon(false);
		}

		// Reset girlfriend to the original character.
		if (PlayState.instance.currentStage.getGirlfriend() != null) {
			var exCharacter = CharacterDataParser.fetchCharacter(defaultChararcters.girlfriend);
			PlayState.instance.currentStage.getGirlfriend().destroy();
			PlayState.instance.currentStage.addCharacter(exCharacter, types.get("gf"));
		}

		// Reset dad to the original character.
		if (PlayState.instance.currentStage.getDad() != null) {
			var exCharacter = CharacterDataParser.fetchCharacter(defaultChararcters.opponent);
			PlayState.instance.currentStage.getDad().destroy();
			PlayState.instance.currentStage.addCharacter(exCharacter, types.get("dad"));
			exCharacter.initHealthIcon(false); 
		}

		// Refresh the stage for good measure.
		PlayState.instance.currentStage.refresh();
	}
}
